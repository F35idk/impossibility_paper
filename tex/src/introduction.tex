
\section{Introduction}
Key encapsulation mechanisms (KEMs) and authenticated key exchange (AKE) protocols are essential primitives in public-key cryptography.
In short, a KEM allows a user to encapuslate a random key $K$ by outputting a ciphertext $C$ using the public key of another user. 
%a pair \((k,c)\)
%consisting of a random key \(k\) and a ciphertext \(c\),
With the corresponding secret key, the designated user can decrypt the ciphertext \(C\) and recover the same key $K$.
%The ciphertext \(c\) is referred to as an \emph{encapsulation} of the key \(k\),
%under the public key of the designated user.
%Any public key encryption scheme easily yields a KEM, and the opposite implication is also true (cite).
KEMs are used as building blocks for many complex public-key cryptosystems. Among them, AKE protocols are (arguably) the most important application, since AKE protocols can exchange a session key between two users to establish a secure channel.
For instance, the promising post-quantum TLS replacement KEMTLS \cite{CCS:SchSteWig20} is a well-known example of KEM-based AKE.


\heading{Security of KEM-based AKE.}
The security requirement for AKE is that an adversary $\advA$ cannot learn information about the shared session key even if $\advA$ manipulates the protocol messages, adaptively corrupt some user long-term keys, and reveal keys of some sessions. This is more complicated than 

\iffalse
\begin{figure}[t]
	\centering
	\begin{pcimage}
		\fbox{  
			\centering
			\pseudocode[colspace=-2.5em]{%
				\textbf{Party } P_i: (\akeCCApk_i, \akeCCAsk_i) \<  \< \textbf{Party } P_j: (\akeCCApk_j, \akeCCAsk_j) \\[0.1\baselineskip][\hline]
				\<\< \\[-0.8\baselineskip]
				(\akeCPApk, \akeCPAsk) \from \akeCPAKEMKG(1^\secpar)\\[-0.2\baselineskip] 
				(\akeCCAct_j, \akeCCAkey_j) \from \akeCCAKEMEnc(\akeCCApk_j) \\[-1.2\baselineskip]
				%\akeState := (\akeCPApk, \akeCPAsk, \akeCCAct_j, \akeCCAkey_j)\\
				\< \sendmessage{->}{top={$(\akeCPApk,\akeCCAct_j)$}, length=3cm} \< \\[-1.2\baselineskip]
				\<\< (\akeCPAct, \akeCPAkey) \from \akeCPAKEMEnc(\akeCPApk)\\
				\<\< \akeCCAkey_j := \akeCCAKEMDec(\akeCCAsk_j, \akeCCAct_j)\\
				\<\< (\akeCCAct_i, \akeCCAkey_i) \from \akeCCAKEMEnc(\akeCCApk_i)\\[-1.2\baselineskip]
				\< \sendmessageleft{top={$(\akeCPAct, \akeCCAct_i)$}, length=3cm} \< \\[-0.8\baselineskip]
				\akeCPAkey := \akeCPAKEMDec(\akeCPAsk, \akeCPAct) \<\< \context := (\akeCCApk_i, \akeCCApk_j, \akeCPApk, \akeCCAct_i, \akeCCAct_j, \akeCPAct) \\[-0.2\baselineskip] 
				\akeCCAkey_i := \akeCCAKEMDec(\akeCCAsk_i, \akeCCAct_i) \<\< 
				\SessionKey := \akeHash(\context, \akeCCAkey'_i, \akeCCAkey'_j, \akeCPAkey') \\[-0.2\baselineskip] 
				\context := (\akeCCApk_i, \akeCCApk_j, \akeCPApk, \akeCCAct_i, \akeCCAct_j, \akeCPAct)\\[-0.2\baselineskip] 
				%				\<\< \\[-0.2\baselineskip] 
				\SessionKey := \akeHash(\context, \akeCCAkey'_i, \akeCCAkey'_j, \akeCPAkey') \\[0.1\baselineskip][\hline]
				\<\< \\[-0.8\baselineskip]
				%				\gamechange{$\SessionKey := \akeHash(\context, \akeCCAkey'_i, \akeCCAkey'_j, \akeCPAkey')$}	
				\< \hfil \akeCCAkey'_i := \akeCCAkey_i, \gamechange{$\akeCCAkey'_i:= \akeNCHash{}{(\akeCCApk_i, \akeCCAct_i, \akeCCAkey_i)}$}  \\
				\< \akeCCAkey'_j := \akeCCAkey_j, \gamechange{$\akeCCAkey'_j:= \akeNCHash{}{(\akeCCApk_j, \akeCCAct_j, \akeCCAkey_j)}$}\\
				\<\akeCPAkey' := \akeCPAkey, \gamechange{$\akeCPAkey':= \akeNCHash{}{(\akeCPApk, \akeCPAct, \akeCPAkey)}$} 
			}
		}
		%		\pcdraw{
			%			\path[->] ([xshift=1.5cm,yshift=-1.2mm] start.south) edge node[right]{$\ \akeState$} ([xshift=1.5cm, yshift=3mm] end.north);
			%		}
	\end{pcimage}
	\caption{Our two approaches of constructing tightly secure AKE protocols between two parties from  secure KEMs, $\akeCCAKEM = (\akeCCAKEMSetup, \akeCCAKEMKG, \akeCCAKEMEnc, \akeCCAKEMDec)$ and $\akeCPAKEM = (\akeCPAKEMSetup, \akeCPAKEMKG, \akeCPAKEMEnc, \akeCPAKEMDec)$. Our two approaches only differ on how the final session keys are derived. We mark the difference in our second approach with \gamechange{gray}. $\akeHash$ and $\akeNCHash{}$ are two independent hash functions.}
	%	\jpnote{Need lots of adaptations}
	\label{fig:scheme:vis-akescheme}
\end{figure}
\fi


\heading{Security of KEM.}
The standard notions of security for a key encapsulation mechanism are so-called IND-CPA and IND-CCA security.
These notions capture resistance to attacks in which an adversary receives a single
encapsulation-key-pair \((k,c)\) where \(c\) encapsulates \(k\),
and must distinguish the key \(k\) from a truly random key.
IND-CPA and IND-CCA security blablabla.
On the other hand, in a real-world setting,
an adversary may not be limited to seeing a single encapsulation \(c\)
--- it could receive several encapsulations and then adaptively select which one to attack.
Additionally, the adversary may see encapsulations under different public keys belonging to different users.
In certain contexts, the imagined adversary could even have \emph{inside information}
on the keys encapsulated by certain ciphertexts, or on the secret keys of certain users.
As an example, if the key encapsulation mechanism is used as a component in a key exchange protocol,
then there could be a massive number of users and sessions executing the protocol in parallell,
\TODO{I should change this: the number of users isn't relevant to what I was trying to say here.}
and hence making use of the KEM.
In such a context, it is not unreasonable to expect that an adversary blabla.
To model these adversarial capabilities,
we can extend the basic IND-CPA and IND-CCA security notions.
blabla.
The basic form of such an extended security notion is ECPA security (ref.?),
which is defined in terms of an adversary that may receive multiple encapsulations
on several different users' public keys, and adaptively reveal encapsulations and corrupt users.


\heading{Tight AKE Security from KEM.}
Although ECPA security appears stronger than the standard IND-CPA notion,
it is an easy exercise to prove that any IND-CPA secure KEM is also ECPA secure.
As is standard in provably secure cryptography, this implication is proven via a so-called \emph{reduction}.
In short, a reduction is an algorithm which turns any attack on a cryptographic scheme
into an attack on an underlying problem or scheme.
Using reductions,
cryptographers can provably relate the security of different cryptographic constructions,
and moreover design cryptographic schemes
whose security can be reduced to the difficulty of simpler,
presumed-to-be-difficult computational problems.
Although we can relate the IND-CPA and ECPA security of a KEM using a reduction,
the issue with the reduction in question is that it incurs a potentially large loss
in the quality of the security guarantee. To be more precise,
if the success probability blabla.
\[
  \epsilon_{\redR} \ge ??
\]

What we would much rather prefer is if the blabla
\[
  \epsilon_{\redR} \ge ??
\]
In this case, we call the reduction \emph{tight}.
Tight security reductions are desirable from a practical point of view,
since they give better quantitative security guarantees on the cryptographic construction in question.
This allows the cryptographic construction to be instantiated with smaller parameters, for a given level of security,
leading to increased efficiency.
It is also \TODO{blabla no asymptotic degradation in the security guarantee, theoretically interesting}.
There has been extensive research on constructing cryptographic schemes with tight security reductions (cite).
Blabla.

Unfortunately,
for many realistic, ``extended'' security notions which handle multiple users with adaptive reveals and corruptions,
constructing cryptographic primitives with tight security reductions appears to be a difficult problem.
Blabla \TODO{impossibility results blabla}.
We are thus interested in the following question: is it possible for a KEM to have a tight reduction
which proves ECPA security, from any standard cryptographic assumption?

\subsubsection{HLG21's impossibility result.}

As HLG21 observe, blabla.
and yet no tight reductions are known for these KEMs.

Unlike blabla, HLG21's result blabla.
As HLG21 show, many well-known KEMs satisfy the polynomial rank requirement, such as blablabla.

One important class of KEM constructions which the result of HLG21 does not cover is lattice-based KEMs.
Indeed, as we show in ????, blabla exponential rank.
This leaves open the question of whether a tight security reduction exists e.g for the Regev KEM,
or for other lattice-based constructions.

In this paper, we rule out the existence of such a reduction.
That is, we show the following result.

\TODO{state our results informally.}

\TODO{Also discuss the applications to AKE. Emphasize the ``unconditional'' nature of the results, i.e that they make essentially no requirements on the primitives. Mention how our AKE results answer an open question from JKRS21 about the existence of tight AKE with state reveals in the standard model.}


\TODO{Story line for the intro}
\begin{itemize}
	\item KEM AKE
	\item KEM-based AKE need stronger security requirements for the underlying KEM
	\begin{itemize}
		\item Non-tight security:  IND-CCA is sufficient
		\item Tight security: OW-ChCCA
	\end{itemize}
	\item PWZ23 showed that OW-ChCCA implies ECCA in the ROM. Hence, we only focus on the weaker security ECCA 
	\item Explain why the impossibility from Han et al. cannot be applied to lattices.
	\item Our contributions
	\item Technical overview
\end{itemize}

% In provably secure cryptography, the security of a cryptographic construction is proven via a so-called \emph{reduction}.
% Using a reduction, any attack on a given cryptographic primitive is
% turned into an attack on an underlying, presumed-to-be difficult problem.
% This way, the security of the primitive is reduced to the difficulty of the aforementioned computational problem.
% We can measure the quality of a reduction by considering its \emph{tightness}, which blabla.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
