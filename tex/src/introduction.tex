
\section{Introduction}
Key encapsulation mechanisms (KEMs) and authenticated key exchange protocols are essential primitives in public-key cryptography.
In short, a KEM allows anyone to generate a pair \((k,c)\)
consisting of a random key \(k\) and a ciphertext \(c\) on the key \(k\),
such that only a designated user can decrypt the ciphertext \(c\) and recover the key.
The ciphertext \(c\) is referred to as an \emph{encapsulation} of the key \(k\),
under the public key of the designated user.
Any public key encryption scheme easily yields a KEM, and the opposite implication is also true (cite).
Moreover, KEMs are used as building blocks in more complex public-key constructions such as ????.

The standard notions of security for a key exchange mechanism are so-called IND-CPA and IND-CCA security.
These notions capture resistance to attacks in which an adversary receives a single
encapsulation-key-pair \((k,c)\) where \(c\) encapsulates \(k\),
and must distinguish the key \(k\) from a truly random key.
IND-CPA and IND-CCA security blablabla.
On the other hand, in a real-world setting,
an adversary may not be limited to seeing a single encapsulation \(c\)
--- it could receive several encapsulations and then adaptively select which one to attack.
Additionally, the adversary may see encapsulations under different public keys belonging to different users.
In certain contexts, the imagined adversary could even have \emph{inside information}
on the keys encapsulated by certain ciphertexts, or on the secret keys of certain users.
As an example, if the key exchange mechanism is used as a component in a key exchange protocol,
then there could be a massive number of users and sessions executing the protocol in parallell,
and hence making use of the KEM.
In such a context, it is not unreasonable to expect that an adversary blabla.
To model these adversarial capabilities,
we can extend the basic IND-CPA and IND-CCA security notions.
blabla.
The basic form of such an extended security notion is ECPA security (ref.?),
which is defined in terms of an adversary that may receive multiple encapsulations
on several different users' public keys, and adaptively reveal encapsulations and corrupt users.

Although ECPA security appears stronger than the standard IND-CPA notion,
it is an easy exercise to prove that any IND-CPA secure KEM is also ECPA secure.
As is standard in provably secure cryptography, this implication is proven via a so-called \emph{reduction}.
In short, a reduction is an algorithm which turns any attack on a cryptographic scheme
into an attack on an underlying problem or scheme.
Using reductions,
cryptographers can provably relate the security of different cryptographic constructions,
and moreover design cryptographic schemes
whose security can be reduced to the difficulty of simpler,
presumed-to-be-difficult computational problems.
Although we can relate the IND-CPA and ECPA security of a KEM using a reduction,
the issue with the reduction in question is that it incurs a potentially large loss
in the quality of the security guarantee. To be more precise,
if the success probability blabla.
\[
  \epsilon_{\redR} \ge ??
\]

What we would much rather prefer is if the blabla
\[
  \epsilon_{\redR} \ge ??
\]
In this case, we call the reduction \emph{tight}.
Tight security reductions are desirable from a practical point of view,
since they give better quantitative security guarantees on the cryptographic construction in question.
This allows the cryptographic construction to be instantiated with smaller parameters, for a given level of security,
leading to increased efficiency.
It is also \TODO{blabla no asymptotic degradation in the security guarantee, theoretically interesting}.
There has been extensive research on constructing cryptographic schemes with tight security reductions (cite).
Blabla.

Unfortunately,
for many realistic, ``extended'' security notions which handle multiple users with adaptive reveals and corruptions,
constructing cryptographic primitives with tight security reductions appears to be a difficult problem.
Blabla \TODO{impossibility results blabla}.
We are thus interested in the following question: is it possible for a KEM to have a tight reduction
which proves ECPA security, from any standard cryptographic assumption?

\subsubsection{HLG21's impossibility result.}

As HLG21 observe, blabla.
and yet no tight reductions are known for these KEMs.

Unlike blabla, HLG21's result blabla.
As HLG21 show, many well-known KEMs satisfy the polynomial rank requirement, such as blablabla.

One important class of KEM constructions which the result of HLG21 does not cover is lattice-based KEMs.
Indeed, as we show in ????, blabla exponential rank.
This leaves open the question of whether a tight security reduction exists e.g for the Regev KEM,
or for other lattice-based constructions.

In this paper, we rule out the existence of such a reduction.
That is, we show the following result.

\TODO{state our results informally.}

\TODO{Also discuss the applications to AKE. Emphasize the ``unconditional'' nature of the results, i.e that they make essentially no requirements on the primitives. Mention how our AKE results answer an open question from JKRS21 about the existence of tight AKE with state reveals in the standard model.}


% In provably secure cryptography, the security of a cryptographic construction is proven via a so-called \emph{reduction}.
% Using a reduction, any attack on a given cryptographic primitive is
% turned into an attack on an underlying, presumed-to-be difficult problem.
% This way, the security of the primitive is reduced to the difficulty of the aforementioned computational problem.
% We can measure the quality of a reduction by considering its \emph{tightness}, which blabla.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
