
\section{Preliminaries}

\TODO{introduce notation and things in a short paragraph.}

\subsection{Key exchange mechanisms}

\TODO{Add definition of a KEM.}

\begin{definition}[\((1-\delta)\)-correctness of a KEM]\label{def:corr}
  Let \(\KEM = (\Setup, \KG, \Encaps, \Decaps)\) be a KEM
  and let \(\delta : \mathbb{N} \to \mathbb{R}\) be a function.
  Then \KEM is said to have \emph{\((1-\delta)\)-correctness} if
  \begin{equation}
    \prob{\Decaps{}(\sk,c) \ne k : \params \assign \Setup{}(1^{\lambda}), (\sk,\pk) \assign \KG{}(\params), (c,k) \assign \Encaps{}(\pk)} \le \delta (\lambda)
  \end{equation}
\end{definition}

\TODO{Include the definition of ECPA security from HLG21.
  Motivate why we use a one-way version of their game instead.}

\begin{definition}[OW-ECPA security]\label{def:OWECPA_sec}
  Let \(\KEM = (\Setup, \KG, \Encaps, \Decaps)\) be a KEM
  and let \advA{} be an adversary in the \OWECPA{} game against \KEM (see Figure \ref{fig:ecpa}).
  Then the advantage of \advA{} against \OWECPA in \KEM is given by
  \begin{equation}
    \abs*{\prob{\OWECPA{}_{\KEM}^{\advA}(\mu,\rho,\lambda) \to 1} - 1/\abs{\keyspace}},
  \end{equation}
  where \(\keyspace = \keyspace{}(\params)\) is the encapsulation key space of \KEM.
  \TODO{advantage notation?}
\end{definition}

\begin{figure}
  \begin{pcvstack}[center,space=0.5cm]
    \proc{Game $\OWECPA_{\KEM}^{\advA}(\mu, \rho, \lambda)$}{
      L_{rev}, L_{corr} \assign \List.\\
      \params \assign \Setup{}(1^{\lambda}).\\
      \pcfor i \in [\mu]:\\
      \t (\sk_i,\pk_i) \assign \KG(\params).\\
      \oracle := \{\Enc, \Reveal, \Corrupt\}.\\
      (i^*, j^*, k^*) \assign \advA^{\oracle}(\params,\pk_1, \ldots, \pk_{\mu}).\\
      \pcif i^{*} \notin L_{corr} \land i^{*} \notin L_{rev} \land k^{*} = k_{i^{*},j^{*}}:\\
      \t \pcreturn 1.\\
      \pcelse:\\
      \t \pcreturn 0.
    }
    \proc{Oracle \Enc{}$(i)$}{
      \text{Assume this is the \(j\)-th query to \Enc{} on user \(i\) with } j \in [\rho].\\
      (c_{i,j}, k_{i,j}) \assign \Encaps{}(\pk_i).\\
      \pcreturn c_{i,j}.
    }
    \begin{pchstack}[space=1cm]
      \proc{Oracle \Reveal{}$(i,j)$}{
        L_{rev} \assign L_{rev} \cup \{(i,j)\}.\\
        \pcreturn k_{i,j}.
      }
      \proc{Oracle \Corrupt{}$(i)$}{
        L_{corr} \assign L_{corr} \cup \{i\}.\\
        \pcreturn \sk_i.
      }
    \end{pchstack}
  \end{pcvstack}\caption{}\label{fig:ecpa}
\end{figure}

\subsection{Security games}
\TODO{Explain what this is, informally.}
\TODO{Explain what we mean by a \emph{challenger} and an \emph{adversary}, which is terminology I use frequently.}

\subsection{Reductions}

In our context, a reduction is simply an
algorithm that turns adversaries in one cryptographic
game into adversaries in another cryptographic game.
The class of reductions we will consider
are so-called \emph{simple} reductions.
The definition is due to \TODO{cite}.

\begin{definition}[Simple reduction]
  A reduction \(\redR\) is said to be \emph{simple}
  if it makes only black-box use of the adversary \(\advA\),
  and additionally executes \(\advA\) exactly once
  and to completion.
\end{definition}

We remark that most security proofs in cryptography
consist of (possibly several) simple reductions (\TODO{cite}).

\paragraph{Which direction does the reduction go?}
The ``direction'' of a reduction is a frequent source of confusion.
\TODO{maybe mention that JBLS16 get the directions mixed up --- they are not consistent with their own definitions.}
In a typical complexity-theoretic context,
a reduction that turns an algorithm for problem \(P_{1}\)
into an algorithm for problem \(P_{2}\)
is said to be a reduction \emph{from \(P_{2}\) to \(P_{1}\)}
(we reduce solving \(P_{2}\) to solving \(P_{1}\)).
In our context, we will emphasize the opposite direction.
When we say that a reduction is \emph{from \(P_{1}\) to \(P_{2}\)},
we mean that it turns an algorithm for \(P_{1}\) into an algorithm for \(P_{2}\).
We note that this is also the opposite (or contrapositive) direction of the hardness (or security) implication
\(P_{2} \text{ hard (secure)} \implies P_{1} \text{ hard (secure)}\)
implied by the reduction.
Equivalently,
when referring to the computational assumption that
the problem \(P_{2}\) is hard, we will say that the reduction
is \emph{for basing the hardness (or security) of \(P_{1}\) on the hardness of \(P_{2}\)},
adopting the convention in \TODO{cite}.

We define the security loss of a reduction \redR similarly to ???,
as a maximum over all adversaries \advA of a certain product of the
advantages and running times of \(\redR\) and \(\advA\).

\begin{definition}[Security loss]\label{def:loss}
  Let \(\redR\) be a simple reduction
  taking adversaries in the game \(G_{1}\) to adversaries in the game \(G_{2}\).
  Then the security loss \(\ell : \N \to \N\) of \(\redR\) is given by
  \begin{equation}\label{eq:loss}
    \ell(\lambda) = \sup_{\advA} \left\{ \frac{\epsilon_{\advA}(\lambda)}{\epsilon_{\redR^{\advA}}(\lambda)}\frac{T_{\redR^{\advA}}(\lambda) + T_{\advA}(\lambda)}{T_{\advA}(\lambda)} \right\}
  \end{equation}
  where the maximum is taken over all adversaries \(\advA\) in \(G_{1}\),
  and \((\epsilon_{\advA}, T_{\advA})\) and \((\epsilon_{\redR^{\advA}}, T_{\redR^{\advA}})\)
  denote the advantage and running time of \advA and \(\redR^{\advA}\) in \(G_{1}\) and \(G_{2}\), respectively.
\end{definition}

\begin{remark}
  The numerator \(T_{\redR^{\advA}} + T_{\advA}\) in \eqref{eq:loss}
  represents the total running time of the reduction \(\redR^{\advA}\),
  including the time taken to execute \(\advA\).
  Since \(\redR\) is a simple reduction,
  it executes \(\advA\) exactly once, to completion,
  which explains the additional term \(T_{\advA}\).
\end{remark}

\subsection{Computational assumptions}

When we prove our tightness impossibility results,
we will only be able to rule out tight security
from a specific class of computational assumptions.
That is, we will only be able to show that
a tight reduction for basing the security of a game \(G\)
on the computational assumption \(A\) is impossible,
if the assumption \(A\) is sufficiently restricted.
This is in some sense an inherent limitation,
as we could not rule out a tight reduction
for basing the security of \(G\)
on \emph{any} computational assumption \(A\)
(a standard counterexample to this is to let \(A\) be the assumption that the game \(G\) is secure.
Clearly there is a tight reduction
for basing the security of \(G\) on the assumption \(A\) in this case).
% In order to rule out tight reductions
% for basing the security of \(G\) on the assumption \(A\),
% we will need the assumption \(A\)
% to be sufficiently

In the impossibility results of \TODO{cite},
tight security is ruled out from the class of \emph{non-interactive}
computational assumptions.
These assumptions are modeled by experiments in which an adversary receives a challenge \(c\)
and must output a solution \(s\) to the challenge, with no further interaction between the adversary and the experiment.
Following an observation of \TODO{cite}, we will slightly expand the class of computational assumptions
from which we can rule out tight reductions
compared to \TODO{cite}, without the need for any essentially new techniques.
In \TODO{cite}, it is shown that a tight, simple reduction
for basing the the weak forward secrecy of a certain class of key exchange protocols
on the \emph{Strong Diffie-Hellman} assumption
cannot exist, unless the Strong Diffie-Hellman assumption is itself false.
The key point here is that the Strong Diffie-Hellman assumption is interactive,
and hence does not fit into the class of non-interactive assumptions considered in e.g \TODO{cite}.
Nevertheless \TODO{cite} are able to apply a similar meta-reduction strategy
to the one pioneered in \TODO{cite} to prove their impossibility result.
They observe that their proof carries over to many other
interactive games, so long as the ``winning condition''
in the game is independent of the sequence of interactive oracle queries made by the adversary.

We expand upon the observation of \TODO{cite}
by noting that their proof relies on a second, crucial property of the Strong Diffie-Hellman problem:
namely that the Strong Diffie-Hellman oracle computes its
responses to the adversary's queries
independently of any of the adversary's previous oracle queries.
In other words, the Strong Diffie-Hellman oracle is in a sense ``stateless''
(with respect to the adversary's queries).
Briefly summarized,
this property is needed to ensure that
the meta-reduction of \TODO{cite}
correctly simulates the Strong Diffie-Hellman oracle
towards the reduction, in spite of the fact
that the meta-reduction rewinds the reduction
and hence may have a different history of oracle queries
than the reduction itself.
This will become clearer in the proof of Theorem \ref{thm:etpa},
where we will make explicit use of this property.

We will call the class of computational assumptions
that satisfy the above-mentioned criteria
\emph{simple computational assumptions}.

% \TODO{explain why this is the case.}
% \TODO{give at least a vague reason for why this should allow the proofs to work.}

\begin{definition}[Simple computational assumption]\label{def:simple}
  A simple computational assumption is a tuple \((\Init,\Respond,\Win,\kappa(\cdot))\),
  where \(\kappa : \N \to \R\) is a function,
  \(\Init\) is a probabilistic algorithm
  and \(\Respond\) and \(\Win\) are deterministic algorithms.
  The algorithms are defined as follows:
  \begin{itemize}[label={\textbullet},itemsep=0.1cm]
    \item \(\Init(1^{\lambda}) \to (\state_{\Simple},c)\):
          The probabilistic initiation algorithm
          takes as input the security parameter and outputs a state \(\state_{\Simple}\)
          along with a \emph{challenge} \(c\).
    \item \(\Respond(\state_{\Simple},m) \to m'\):
          The deterministic response algorithm
          takes as input a state \(\state_{\Simple}\)
          and a message \(m\), and outputs a response \(m'\).
    \item \(\Win(\state_{\Simple},s) \to b'\):
          The deterministic algorithm \(\Win\)
          takes as input a state \(\state_{\Simple}\)
          and a \emph{challenge solution} \(s\),
          and outputs a bit \(b'\).
  \end{itemize}

  For a given simple computational assumption \(\Simple = (\Init,\Respond,\Win,\kappa)\)
  and an algorithm \advA, we define a game \(\SICA_{\Simple}^{\advA}\)
  according to Figure \ref{fig:simple}.

  The \emph{advantage of \advA{} against \Simple} is given by
  \begin{equation}\label{eq:simple}
    \abs[\big]{\prob{\SICA_{\Simple}^{\advA}(\lambda) \to 1} - \kappa(\lambda)}.
  \end{equation}

  Moreover, if it holds that for all probabilistic polynomial time adversaries \(\advA\),
  the advantage of \(\advA\) is negligible in \(\lambda\),
  then we say that the simple computational assumption is \emph{hard}.
\end{definition}

\begin{figure}
  \begin{pchstack}[center,space=0.5cm]
    \proc{Game $\SICA_{\Simple}^{\advA}(\lambda)$}{
      \label{code:simple:init} (\state_{\Simple}, c) \assign \Init(1^{\lambda}).\\
      \label{code:simple:output} s \assign \advA^{\oracle}(c).\\
      \label{code:simple:win} b' \assign \Win(\state_{\Simple},s).\\
      \pcreturn b'.
    }
    \proc{Oracle \oracle(m)}{
      \pcreturn \Respond(\state_{\Simple},m).
    }
  \end{pchstack}\caption{}\label{fig:simple}
\end{figure}

In the \SICA game, the algorithm \Init of \Simple
generates a challenge \(c\) which is passed to \advA,
along with an internal state variable \(\state_{\Simple}\)
which the challenger keeps to itself.
The algorithm \Respond of \Simple
is used to compute responses
to \advA's queries throughout the game.
After \advA has output a challenge solution \(s\),
the algorithm \Win of \Simple
is used to determine whether \advA has won the \SICA game:
we say that \advA wins if it computes a challenge solution \(s\)
such that \(\Win(\state_{\Simple},s) = 1\).

\begin{remark}
  We note that none of the algorithms \((\Init,\Respond,\Win)\)
  in our definition need to be efficient.
  In particular, the challenger in a \SICA
  game against a simple computational assumption
  need not be efficient,
  and hence the simple computational assumption need not be \emph{falsifiable},
  using the terminology of \TODO{cite}.
  The predicate \(\Win\) likewise need not be efficient,
  meaning that the winning condition in a \SICA game
  need not be efficiently verifiable.
\end{remark}

\begin{remark}
  It is clear that the class of simple computational assumptions
  contains the class of non-interactive computational assumptions.

  \TODO{say something about how this extends non-interactive assumptions.
  Argue that it is \emph{strictly} stronger than non-interactive assumptions.}
  \TODO{say something about how CCA-type games can be modeled by this. And stDH}.
\end{remark}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
