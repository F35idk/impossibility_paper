
\section{The KEM impossibility result}

The following theorem is the main result of the section.

\begin{theorem}[Impossibility of tight \OWECPA reductions]\label{thm:main}
  Let \(\KEM = (\Setup, \KG, \Encaps, \Decaps)\) be a KEM
  with \((1-\delta)\)-correctness
  and let \(\Simple = (\Init, \Respond, \Win,\kappa(\cdot))\)
  be a simple computational assumption.
  Assuming that \Simple is hard
  and \(\delta\) is negligible,
  any simple \((\mu,\rho)\)-reduction \redR
  from breaking the \OWECPA security of \KEM to breaking \Simple
  must lose a factor \(\ell\), where
  \begin{equation}\label{eq:main}
    \ell = \Omega(\mu) \text{ and } \ell = \Omega(\rho^{1-\epsilon}) \text{ for any } \epsilon > 0.
  \end{equation}
\end{theorem}

As discussed (\TODO{add}), \OWECPA security is weaker the \INDECPA security,
which in turn is weaker than \INDECCA security.
Moreover, there are tight reductions relating these games
(\TODO{add a proof of this in the appendix?}).
From this and the discussion in (\TODO{discuss}),
we derive the following theorem as a corollary of Theorem \ref{thm:main}.

\begin{theorem}[Impossibility of tight \INDECPA/\INDECCA reductions]
  Let \(\KEM = (\Setup, \KG, \Encaps, \Decaps)\) be a KEM
  with \((1-\delta)\)-correctness
  and let \(\Simple = (\Init, \Respond, \Win,\kappa(\cdot))\)
  be a simple computational assumption.
  Assuming that \Simple is hard
  and \(\delta\) is negligible,
  any simple \((\mu,\rho)\)-reduction \redR
  from breaking either the \INDECPA or \INDECCA security of \KEM to breaking \Simple
  must lose a factor \(\ell\),
  where the same bounds as in \eqref{eq:main} hold.
\end{theorem}

The above results will in fact be obtained as corollaries
of the following technical theorem, which is the main workhorse of this section.

\begin{theorem}[Bounding the security loss of an \OWECPA reduction]\label{thm:owecpa}
  Let \(\KEM = (\Setup, \KG, \Encaps, \Decaps)\) be a KEM
  with \((1-\delta)\)-correctness,
  ciphertext space \setC, encapsulation key space \keyspace
  and secret key space \(\setSK \subset \{0,1\}^{q(\lambda)}\) for some polynomial \(q\),
  where \(\lambda\) is the security parameter.
  Let \(\Simple = (\Init, \Respond, \Win,\kappa(\cdot))\) be a simple computational assumption
  with corresponding game \(\SICA\) as in \TODO{ref.},
  and let \(\redR\) be a simple
  \((\mu,\rho)\)-reduction
  from breaking the \OWECPA security of \KEM to breaking
  the \SICA security of \Simple.
  Let \(t \in \N, \alpha \in (0,1)\) with \(t \le \rho/3\).
  Then there exists an (inefficient \TODO{?})
  \((\mu,\rho)\)-adversary \advA against \(\OWECPA\) security in \KEM
  whose success probability is at least
  \begin{equation}\label{ineq:A}
    p_{\advA} \ge 1 - \alpha - \delta \mu \rho
    - 4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t},
  \end{equation}
  and an adversary \redM in the game \(\SICA\) whose advantage \(\epsilon_{\redM}\) satisfies
  \begin{equation}\label{ineq:M}
    \abs{\epsilon_{\redR^{\advA}} - \epsilon_{\redM}} \le 1/\mu + \alpha
    + 4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t},
  \end{equation}
  where \(\epsilon_{\redR^{\advA}}\) denotes the advantage of \(\text{ }\redR^{\advA}\) in \SICA.

  Moreover, the running time of \redM is of the form
  \begin{equation}\label{ineq:M:time}
    T_{\redM} \le (\mu + 1) \cdot T_{\redR^{A}} + (\mu \rho + 1) \cdot T_{\Decaps},
  \end{equation}
  where \(T_{\Decaps}\) denotes the running time of the decapsulation algorithm
  \(\Decaps\) of \KEM, and \(T_{\redR^{A}}\) denotes the running time of \(\redR^{A}\),
  not including the time taken to execute \(\advA\).
  % Moreover, the running time of \redM is polynomial in the parameters \((\mu, \rho)\),
  % and if the running time of the reduction \(\redR^{A}\) is polynomial in \(\lambda\),
  % where we consider the time taken to execute \(\advA\) to be constant,
  % then the running time of the adversary \redM will be polynomial in \((\lambda,\mu,\rho)\).
\end{theorem}

\begin{remark}[Interpretation of the theorem statement]
  \TODO{write this.}
\end{remark}

Before we give a proof of Theorem \ref{thm:owecpa},
we will show how it can be used to obtain Theorem \ref{thm:main}.

\begin{namedproof}{Proof of Theorem \ref{thm:main}}
  \TODO{Do the details.}
\end{namedproof}

In order to pave the way for a proof of Theorem \ref{thm:owecpa},
we will find it useful to introduce some terminology.

\begin{definition}[Agreeing pairs]\label{def:agree}
  Let \setSK, \setC, \keyspace be sets and
  let \(f : \setSK \times \setC \to \keyspace\) be a function.
  Fix a \(c \in \setC\) and a pair \((s,s') \in \setSK^{2}\).
  Then \(s\) and \(s'\) are said to \emph{agree on \(c\) with respect to \(f\)} if
  \(
    f(s,c) = f(s',c).
  \)
  When \(f\) is understood from context, we simply say that \(s\) and \(s'\) \emph{agree on \(c\)}.
  On the other hand, if
  \(
    f(s,c) \ne f(s',c),
  \)
  then we say that \(s\) and \(s'\) \emph{disagree on \(c\)} (with respect to \(f\)).
\end{definition}

\TODO{say something about what picture the reader should have in his mind.}

\begin{definition}[Bad pairs]\label{def:bad}
  \TODO{pick a better name than ``bad''.}
  Let \setSK, \setC, \keyspace, \(f : \setSK \times \setC \to \keyspace\) be as before.
  Fix a set \(A \subset \setC\) and a subset \(S \subset A\),
  along with a pair \((s,s') \in \setSK^{2}\) and a real number \(\alpha \in (0,1)\).
  Then \((s,s')\) is said to be \emph{\(\alpha\)-bad for the subset \(S\)} (with respect to \(A\) and \(f\)) if
  \(s\) and \(s'\) agree on every \(c \in A \setminus S\), yet disagree on more than an \(\alpha\)-fraction of \(c \in S\).
  In other words, \((s,s')\) is \(\alpha\)-bad for the subset \(S\) if we have
  \(
    f(s,c) = f(s',c) \text{ for all } c \in A \setminus S,
  \)
  but
  \(
    f(s,c) \ne f(s',c) \text{ for more than } \alpha \abs{S} \text{ distinct } c \in S.
  \)
  % When \(\alpha\) is clear from context, we simply say that \((s,s')\) is \emph{bad for the subset \(S\)} (with respect to \(A\) and \(f\)).
\end{definition}

\TODO{Say a word about the following lemma. ``The lemma we have talked about in the proof overview.''}

\begin{lemma}[Probability of bad pairs]\label{lemma:equiv}
  Let \setSK, \setC, \keyspace, \(f : \setSK \times \setC \to \keyspace\) be as before.
  Let \(\alpha \in (0,1)\) and \(d,\rho,t \in \N\) with \(t \le \rho/3\),
  and assume that \(\setSK \subset \{0,1\}^{d}\).
  Fix a set \(A \subset \setC\) of size \(\rho\)
  and let \(S \subset A\) be a uniformly random size-\(t\) subset of \(A\).
  Then
  \begin{align}\label{ineq:equiv}
    \prob*{\exists (s,s') \in \setSK^{2} : (s,s') \text{ is \(\alpha\)-bad for } S \text{ w.r.t \(A\) and \(f\)}}
    \le 4^{d} \cdot \left. \binom{\rho - \alpha t}{t - \alpha t} \middle/ \binom{\rho}{t} \right..
  \end{align}
\end{lemma}

\begin{proof}
  In the following, when we say that a pair \((s,s')\) is \(\alpha\)-bad for a subset \(S\),
  we mean that it is \(\alpha\)-bad for \(S\) \emph{with respect to \(f\) and \(A\)}.
  We will bound the probability that a fixed pair \((s,s')\) is \(\alpha\)-bad for \(S\),
  and then take a union bound over all pairs in \(\setSK^{2}\) to get \eqref{ineq:equiv}.
  So fix a pair \((s,s')\).
  We claim that \((s,s')\) can be \(\alpha\)-bad for at most \(\binom{\rho - \alpha t}{t - \alpha t}\) size \(t\) subsets of \(A\).
  To see this, first observe that the only size \(t\) subsets for which \((s, s')\) can be \(\alpha\)-bad
  are those containing every \(c \in A\) on which \(s\) and \(s'\) disagree.
  This follows from the definition of ``badness'':
  if \((s,s')\) is \(\alpha\)-bad for a subset \(S' \subset A\),
  then \(s\) and \(s'\) must agree on every \(c \in A\) which is outside of \(S'\),
  and hence they can only disagree \emph{inside} of the subset \(S'\).
  Now assume that there are exactly \(k\) distinct \(c \in A\) on which \(s\) and \(s'\)
  disagree, and denote the set of these \(c \in A\) by \(D\).
  Then, by the preceding argument, the number of size \(t\) subsets of \(A\) for which \((s, s')\)
  can be \(\alpha\)-bad equals the number of size \(t\) subsets of \(A\) that contain \(D\).
  But this is exactly
  \[
    \binom{\abs{A} - \abs{D}}{t - \abs{D}} = \binom{\rho - k}{t - k}.
  \]
  Now, if \((s, s')\) is \(\alpha\)-bad for any size \(t\) subset at all, then \(k > \alpha t\). Hence
  \[
    \binom{\rho - k}{t - k} \le \binom{\rho - k}{t - \alpha t} \le \binom{\rho - \alpha t}{t - \alpha t},
  \]
  where the first inequality holds if we take
  \(
    t - \alpha t \le (\rho - k)/2
  \)
  (by the increasing property of binomial coefficients),
  for which it is sufficient to have
  \(
    t - \alpha t \le (\rho - t)/2,
  \)
  since \(t \ge k\).
  Taking e.g \(t \le (\rho - t)/2 \iff t \le \rho / 3\) ensures this,
  since \(\alpha t \ge 0\).

  Now denote the family of all size \(t\) subsets \(S' \subset A\) for which \((s,s')\) is \(\alpha\)-bad by \(\mathcal{F}\).
  Then, as we have seen, \(\abs{\mathcal{F}} \le \binom{\rho - \alpha t}{t - \alpha t}\).
  And since \(S\) is picked uniformly among the \(\binom{\rho}{t}\) size \(t\) subsets
  of \(A\), we have
  \begin{equation}\label{ineq:badprob}
    \prob{(s,s') \text{ \(\alpha\)-bad for } S}
    = \sum_{S' \in \mathcal{F}}{\prob*{S = S'}}
    = \sum_{S' \in \mathcal{F}}{{\binom{\rho}{t}}^{-1}}
    \le {\binom{\rho}{t}}^{-1} \binom{\rho - \alpha t}{t - \alpha t}.
  \end{equation}
  % where for the final inequality we have used that \(\abs{\mathcal{F}} \le \binom{\rho - \alpha t}{t - \alpha t}\).
  % the pair \((s, s')\) is
  % \(\alpha\)-bad for at most \(\binom{\rho - \alpha t}{t - \alpha t}\) size \(t\) subsets of \(A\).
  Remembering that \(\setSK \subset \{0,1\}^{d}\) and hence
  \(\abs{\setSK^{2}} \le \abs{\{0,1\}^{2d}} = 4^{d}\),
  we now get \eqref{ineq:equiv} by taking a union bound over all pairs \((s,s') \in \setSK^{2}\)
  and applying the inequality in \eqref{ineq:badprob}.
\end{proof}

\begin{remark}
  \TODO{Say something about the lack of dependence on the function \(f\) in the lemma (it can be anything).}
\end{remark}

% In order for the bound in Lemma \ref{lemma:equiv} to be useful,
% we need the quotient of binomial coefficients in \eqref{ineq:equiv}
% to be significantly smaller than \(4^{d}\).
% This will depend on how we choose our parameters \(\rho, \alpha\) and \(t\).
% Importantly, we will be in a position to choose these parameters freely,
% so that the bound can indeed be made effective.
The following corollary bounds the quotient of binomial coefficients in \eqref{ineq:equiv}
trivially (\TODO{does it though?}), but will be good enough for our purposes.

\begin{corollary}\label{corollary:equiv}
  With the same setup as in Lemma \ref{lemma:equiv}, we have
  \begin{equation}\label{ineq:corollary:equiv}
    \prob*{\exists (s,s') \in \setSK^{2} : (s,s') \text{ is \(\alpha\)-bad for } S \text{ w.r.t \(A\) and \(f\)}}
    \le 4^{d} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \end{equation}
\end{corollary}

\begin{proof}
  This follows from the simple fact that for \(k \le n \le m\),
  \begin{align}
    \left. \binom{m - k}{n - k} \middle/ \binom{m}{n} \right.
    = \frac{(m-k)!}{(n-k)!(m-n)!} \frac{n!(m-n)!}{m!}
    = \frac{n!}{(n-k)!} \frac{(m-k)!}{m!} \notag
    & \le n^{k} \frac{(m-k)!}{m!} \notag\\
    & \le n^{k} (m-k+1)^{-k} \notag\\
    & = \left( \frac{n}{m - k + 1} \right)^{k}. \notag
  \end{align}
  Applying this inequality to \eqref{ineq:equiv} gives the result.
\end{proof}

We now turn to the proof of Theorem \ref{thm:owecpa}.
\TODO{fix proof name.}

\begin{proof}[Proof of Theorem \ref{thm:owecpa}]
  We begin by describing the adversary \advA against \OWECPA security in \KEM
  and the meta-reduction \redM against the simple computational assumption \Simple.
  Let \(\rho, \mu, t \in \N, \alpha \in (0,1)\) be as given in the theorem statement.
  The adversary \advA is given as follows:

  \begin{enumerate}[itemsep=0.1cm]
    \item Receive \(\params, \pk_{1}, \ldots, \pk_{\mu}\) from the \(\OWECPA(\KEM)\) challenger.
    \item Query \(\Enc(i)\) \(\rho\) times for each \(i \in [\mu]\) and receive encapsulations \((c_{i,j})_{i \in [\mu], j \in [\rho]}\).
    \item For each \(i \in [\mu]\), do the following:
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
            \item Pick a uniformly random size \(t\) subset \(S_{i} \subset [\rho]\).
            \item Query \(\Reveal(i,j)\) for each \(j \in [\rho] \setminus S_{i}\)
                  and receive keys \((k_{i,j})_{j \in [\rho] \setminus S_{i}}\).
          \end{itemize}
    \item\label{advA:corrupt} Sample \(i^{*} \sampleR [\mu]\). Then repeat the following for each \(i \in [\mu]\) with \(i \ne i^{*}\):
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
            \item Query \(\Corrupt(i)\) and receive \(\sk_{i}\).
            \item Abort if \(\Decaps(\sk_{i},c_{i,j}) \ne k_{i,j}\) for some \(j \in [\rho] \setminus S_{i}\).
          \end{itemize}
     \item\label{advA:brute} Brute-force search for a candidate \(\sk_{i^{*}} \in \{0,1\}^{q(\lambda)}\) as follows:
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
            \item For each \(\sk \in \{0,1\}^{q(\lambda)}\),
                  check whether \(\Decaps(\sk,c_{i^{*},j}) = k_{i^{*},j}\) for each \(j \in [\rho] \setminus S_{i^{*}}\).
            \item If so: set \(\sk_{i^{*}} := \sk\) and exit the loop. Otherwise: continue.
            \item If no \(sk_{i^{*}}\) was found during the brute-force search: abort.
          \end{itemize}
    \item\label{advA:final} Sample \(j^{*} \sampleR S_{i^{*}}\),
          and use \(\sk_{i^{*}}\) to compute a candidate key \(k_{i^{*}, j^{*}} \assign \Decaps(\sk_{i^{*}},c_{i^{*}, j^{*}})\).
          Output \((i^{*}, j^{*}, k_{i^{*}, j^{*}})\) in the \OWECPA game.
  \end{enumerate}

  Observe that Step \ref{advA:brute} of the adversary \advA involves a brute-force search
  over all \(\sk \in \{0,1\}^{q(\lambda)}\), which is inefficient.
  The aim of the meta-reduction \redM is to break the simple computational assumption \Simple,
  by simulating the adversary \advA towards the reduction \redR \emph{efficiently},
  hence turning \(\redR^{\advA}\) into an efficient adversary against \Simple.
  Accordingly, \redM is itself an adversary against \Simple,
  or more precisely an adversary in the game \SICA against \Simple
  (recall Figure \ref{fig:simple} of Definition \ref{def:simple}).
  In particular, it has access to an oracle \oracle,
  which it uses to simulate the corresponding oracle for \(\redR\).
  Also note that the meta-reduction \redM only needs to simulate a single
  execution of \advA towards \redR,
  since we are assuming that the reduction \redR is simple
  and hence only executes \advA once.
  We describe \redM in the following.

  \begin{enumerate}[itemsep=0.1cm]
    \item Receive the challenge \(c\) from the \(\SICA\) challenger.
    \item Run \(\redR^{\oracle,\advA}(c)\) while simulating \advA towards \(\redR^{\oracle}\),
          but halt the execution of \(\redR^{\oracle}\) when Step \ref{advA:corrupt} of \advA
          is first reached.
    \item\label{advM:rewind}
          Rewind the reduction \(\redR^{\oracle}\) \(\mu\) times as follows:
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
            \item Starting from the point at which \(\redR^{\oracle}\) was halted in
                  the previous step, execute \(\redR^{\oracle}\) while simulating Step
                  \ref{advA:corrupt} of \advA towards \(\redR^{\oracle}\),
                  for each of the \(\mu\) possible values of \(i^{*}\)
                  that \advA could pick in Step \ref{advA:corrupt}.
            \item While simulating Step \ref{advA:corrupt} of \advA
                  with the value \(i^{*}\) set to \(i^{*} = \ell\),
                  store the secret keys received by \advA's queries to \(\Corrupt(i)\)
                  as \((\sk_{i}^{\ell})_{i \in [\mu] \setminus \{\ell\}}\).
          \end{itemize}
    \item\label{advM:sample} Rerun \(\redR^{\oracle}\) for a final time while simulating Step \ref{advA:corrupt} of \advA, this time for a uniformly random \(i^{*} \sampleR [\mu]\).
        \begin{itemize}[label={\textbullet},itemsep=0.1cm]
                \item If the simulation of \advA aborts during this step:
                simply run \(\redR^{\oracle}\) to completion (in this case, our task of simulating \advA is trivial since \advA has aborted).
                Afterwards, terminate and output whatever \(\redR^{\oracle}\) outputs in the game \SICA.
                \item Otherwise: go to the next step.
        \end{itemize}
    \item\label{advM:key} For each \(\ell \in [\mu]\), repeat the following:
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
            \item Check if the secret key \(\sk_{i^{*}}^{\ell}\)
                  stored in Step \ref{advM:rewind} satisfies that
                  \(\Decaps(sk_{i^{*}}^{\ell},c_{i^{*},j}) = k_{i^{*},j}\)
                  for each \(j \in [\rho] \setminus S_{i^{*}}\).
            \item If so, denote this secret key by \(\sk_{i^{*}}'\) and exit the loop.
                  If not: continue to the next \(\ell\).
            \item If no secret key \(\sk_{i^{*}}'\) satisfying the above
                  was found during the entire loop: abort.
          \end{itemize}
    \item\label{advM:final} Finally: use \(\sk_{i^{*}}'\) to simulate the last part of \advA's execution towards \(\redR^{\oracle}\):
          \begin{itemize}[label={\textbullet},itemsep=0.1cm]
                  \item Pick \(j^{*} \sampleR S_{i^{*}}\) and compute \(k_{i^{*},j^{*}}' \assign \Decaps(\sk_{i^{*}}',c_{i^{*},j^{*}})\).
                  \item Let \advA output \((i^{*},j^{*}, k_{i^{*},j^{*}}')\) to \(\redR^{\oracle}\),
                  as it would in the \OWECPA game.
            \item Afterwards, continue running \(\redR^{\oracle}\)
                  until termination, and output whatever \(\redR^{\oracle}\)
                  outputs in the game \SICA.
          \end{itemize}
  \end{enumerate}

  To prove the theorem, we need to prove the inequalities \eqref{ineq:A} and \eqref{ineq:M},
  and also argue that the running time of the meta-reduction \redM is of the form in \eqref{ineq:M:time}.
  We defer the proof of \eqref{ineq:A} to Lemma \ref{lemma:A}.
  As for the running time of \redM,
  observe that \redM rewinds the reduction \redR exactly \(\mu\) times,
  and additionally runs \redR to completion exactly once.
  Moreover, \redM uses the decapsulation algorithm \Decaps of the KEM \KEM
  at most \(\mu \rho\) times during Step \ref{advM:key},
  and exactly once in Step \ref{advM:final}.
  The bound in \eqref{ineq:M:time} now follows.

  It remains to show that \eqref{ineq:M} holds, i.e to bound the difference
  \(
    \abs{\epsilon_{\redR^{\advA}} - \epsilon_{\redM}},
  \)
  where \(\epsilon_{\redR^{\advA}}\) and \(\epsilon_{\redM}\) denote
  the advantages of \(\redR^{\advA}\) and \redM, respectively, in the game \SICA
  against the simple computational assumption \Simple.
  This amounts to showing that the meta-reduction \redM
  emulates the reduction \redR successfully
  (by simulating the adversary \advA towards \redR),
  except with some (hopefully small) probability equal to the right hand side of \eqref{ineq:A}.
  For this, we will have to analyze the execution of \redM and \(\redR^{A}\)
  in the game \SICA against \Simple.
  Let us denote the instances of the \SICA game played by \redM and \(\redR^{\advA}\)
  by \(\SICA_{\Simple}^{\redM}\) and \(\SICA_{\Simple}^{\redR}\), respectively.
  To simplify the analysis, we will define \(\SICA_{\Simple}^{\redM}\)
  and \(\SICA_{\Simple}^{\redR}\) over the same probability space.
  More precisely, we assume that the \(\Init\) algorithm of \Simple
  is given the same random coins in line \ref{code:simple:init} of Figure \ref{fig:simple}
  in either instance of the \SICA game.
  From this, it follows that the tuple \((\state_{\Simple},c)\) of state and challenge
  output by \(\Init\) is identical in \(\SICA_{\Simple}^{\redM}\) and \(\SICA_{\Simple}^{\redR}\).
  Now denote the challenge solutions output by \redM and \(\redR^{\advA}\)
  in \(\SICA_{\Simple}^{\redM}\) and \(\SICA_{\Simple}^{\redR}\)
  by \(s_{\redM}\) and \(s_{\redR}\), respectively (corresponding to line \ref{code:simple:output} of Figure \ref{fig:simple})
  (\TODO{refer to \(s\) as a challenge solution in the definition of \SICA}).
  We claim that
  \begin{equation}\label{ineq:owecpa:diff}
    \abs{\epsilon_{\redM} - \epsilon_{\redR^{\advA}}} \le \prob{s_{\redM} \ne s_{\redR}}.
  \end{equation}
  It follows that it will be enough to bound the probability \(\prob{s_{\redM} \ne s_{\redR}}\),
  i.e to bound the probability that \(\redR^{\advA}\) and \(\redM\)
  output different challenge solutions.
  We give such a bound in Lemma \ref{lemma:M}, from which the inequality \eqref{ineq:M} will follow.

  Proving that the inequality \eqref{ineq:owecpa:diff} holds
  essentially amounts to a ``difference lemma'' argument,
  although we will need to make use of the fact that \Simple is a simple computational assumption,
  as defined in Definition \ref{def:simple}.
  Indeed, observe that the winning condition in the game \SICA
  is defined by the deterministic algorithm \(\Win\) of \(\Simple\),
  which takes as input only the state \(\state_{\Simple}\) of the game and a challenge solution \(s\)
  (in particular, it does not depend on the queries made to the oracle \oracle
  in the game).
  In other words, the winning condition depends only on the state
  \(\state_{\Simple}\) and the challenge solution \(s\).
  Since the states of \(\SICA_{\Simple}^{\redM}\) and \(\SICA_{\Simple}^{\redR}\)
  are equal by assumption, we find that if \(s_{\redM} = s_{\redR}\), then
  \[
  \SICA_{\Simple}^{\redR} \to 1 \iff \Win(\state_{\Simple},s_{\redM}) = 1 \iff \Win(\state_{\Simple},s_{\redM}) = 1 \iff \SICA_{\Simple}^{\redM} \to 1.
  \]
  (\TODO{change arrow notation?}).
  By the usual difference lemma (\TODO{add this}), we get
  \[
    \abs{\prob{\SICA_{\Simple}^{\redR} \to 1} - \prob{\SICA_{\Simple}^{\redM} \to 1}}
    \le \prob{s_{\redM} \ne s_{\redR}},
  \]
  which gives
  \begin{align}
    \abs{\epsilon_{\redM} - \epsilon_{\redR^{A}}}
    & = \abs*{\abs{\prob{\SICA_{\Simple}^{\redR} \to 1} - \kappa(\lambda)} - \abs{\prob{\SICA_{\Simple}^{\redM} \to 1} - \kappa(\lambda)}} \notag\\
    & \le \abs*{(\prob{\SICA_{\Simple}^{\redR} \to 1} - \kappa(\lambda)) - (\prob{\SICA_{\Simple}^{\redM} \to 1} - \kappa(\lambda))} \notag\\
    & = \abs*{\prob{\SICA_{\Simple}^{\redR} \to 1} - \prob{\SICA_{\Simple}^{\redM} \to 1}} \notag\\
    & \le \prob{s_{\redM} \ne s_{\redR}} \notag,
  \end{align}
  as desired.
\end{proof}

\begin{lemma}\label{lemma:M}
  With the same setup as above,
  \begin{equation}
    \prob{s_{\redM} \ne s_{\redR}}
    \le 1/\mu + \alpha
    + 4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \end{equation}
\end{lemma}

\begin{proof}
  To prove the lemma,
  we will need to argue that the executions of the meta-reduction \redM
  and the reduction \(\redR^{\advA}\) are ``close'' enough
  that they are likely to output the same challenge solution \(s_{\redM} = s_{\redR}\)
  in the \SICA game against \Simple.
  To do this, we will need to show that \redM simulates \advA
  correctly towards \(\redR\), except with some prescribed failure probability.
  For this analysis, we will continue to make the assumption that
  the instance \(\SICA_{\Simple}^{\redR}\) of the \SICA game played by \(\redR^{A}\)
  and the instance \(\SICA_{\Simple}^{\redM}\) of the \SICA game played by \redM
  are defined over the same probability space.
  This includes taking the randomness of the real adversary
  \advA run by \(\redR^{\advA}\)
  and the simulated adversary run by \redM to be the same,
  wherever convenient.
  With this in mind, we will see that
  the proof essentially reduces to arguing that
  the key \(k_{i^{*},j^{*}}'\) computed by the meta-reduction
  \redM in Step \ref{advM:final} of its execution in \(\SICA_{\Simple}^{\redM}\)
  equals the key \(k_{i^{*},j^{*}}\)
  that the real adversary \advA computes in Step \ref{advA:final} of its execution,
  when \redR runs \advA in \(\SICA_{\Simple}^{\redR}\).
  This is where we will need to make use of Lemma \ref{lemma:equiv}.

  Before we can argue about the key \(k_{i^{*},j^{*}}'\) computed by
  \redM in Step \ref{advM:final} of its execution,
  we will need to address the possibility that \redM aborts
  before ever reaching this step.
  Indeed, this can happen in Step \ref{advM:key},
  if \redM fails to find a secret key \(\sk_{i^{*}}'\)
  of the appropriate form among the \(\mu - 1\)
  different secret keys \(\sk_{i^{*}}^{\ell}\) it has saved.
  More precisely, this will happen if
  none of the secret keys \(\sk_{i^{*}}^{\ell}\)
  which were stored by \redM during the rewinding of \redR in Step \ref{advM:rewind}
  satisfy the following check:
  \begin{equation}\label{skcheck}
  \Decaps(\sk_{i^{*}}^{\ell},c_{i^{*},j}) = k_{i^{*},j}
  \text{ for each } j \in [\rho] \setminus S_{i^{*}}.
  \end{equation}
  Let \(\eventE_{abrt}\) denote the event that \redM aborts in Step \ref{advM:key}, or more precisely
  \[
    \eventE_{abrt} := \text{\redM reaches Step \ref{advM:key}, but for all } \ell \in [\mu],
    \text{ the secret key } \sk_{i^{*}}^{\ell}
    \text{ fails to satisfy the check in \eqref{skcheck}. }
  \]
  We claim that \(\prob{\eventE_{abrt}} \le 1/\mu\).
  The precise argument here is somewhat subtle,
  although it is standard and follows the argument in \TODO{HLG21, which page?},
  which in turn borrows from the meta-reduction technique for \TODO{something signatures something?}
  pioneered by \cite{EC:BJLS16}.
  \TODO{finish the argument here.}
  % Hence we will only give a brief sketch here.
  % The idea is that, if \redM fails to receive a secret key of the desired form,
  % then with high probability over the choice of \(i^{*}\), \advA{} will abort,
  % so that \redM's simulation of \advA succeeds trivially (and \(\eventE_{abrt}\) does not occur).
  % \TODO{say something more.}

  Now let us consider what happens if \(\eventE_{abrt}\) does not occur.
  In this case, we claim that, so long as the key
  \(k_{i^{*},j^{*}}'\) computed by \redM
  and the key \(k_{i^{*},j^{*}}\) computed by \advA
  are equal,
  then \redM simulates \advA \emph{perfectly}
  towards \redR,
  and the challenge solution \(s_{\redR}\) output by \(\redR^{\advA}\) in \(\SICA_{\Simple}^{\redR}\)
  will equal the challenge solution \(s_{\redM}\) output by \(\redM\)
  in \(\SICA_{\Simple}^{\redM}\).
  To see this, observe that the meta-reduction \redM simulates \advA
  perfectly until Step \ref{advM:final} of \redM's execution.
  This relies in particular on the fact that the oracle \oracle
  in the \SICA game is ``stateless''.
  Indeed, notice that the meta-reduction \redM is simply
  using its own oracle \oracle in \(\SICA_{\Simple}^{\redM}\)
  directly to simulate the corresponding oracle for \redR in \(\SICA_{\Simple}^{\redM}\).
  Since the two instances of the \SICA game are defined over the same probability space,
  and in particular share the same state \(\state_{\Simple}\),
  the responses computed by the oracle \oracle
  in either game will be the same.
  Recalling Figure \ref{fig:simple} of Definition \ref{def:simple},
  this is because the oracle \oracle simply computes its response to a query \(m\)
  as \(\Respond(\state_{\Simple},m)\).
  % Note that this holds in spite of the fact that \(\redM\)
  % may possibly make many more (and different) queries to \oracle than \(\redR^{A}\),
  % since \(\redM\) rewinds the reduction \redR
  % and executes it several times.

  Now, when \redM reaches Step \ref{advM:final} of its execution,
  the only step of \advA which remains to simulate is the
  final step (Step \ref{advA:final} of \advA), in which \advA outputs
  a triple \((i^{*},j^{*},k_{i^{*},j^{*}})\).
  Since we assume \(\eventE_{abrt}\) has not occurred,
  \redM has obtained a secret key \(\sk_{i^{*}}'\)
  satisfying the check in \eqref{skcheck},
  and will compute a key as \(k_{i^{*},{j^{*}}}' \assign \Decaps(\sk_{i^{*}}'c_{i^{*},j^{*}})\).
  Afterwards, \redM simply simulates \advA
  by outputting \((i^{*},j^{*}, k_{i^{*},j^{*}}')\) to \(\redR^{\oracle}\),
  and continues running \(\redR^{\oracle}\)
  until termination, outputting whatever \(\redR^{\oracle}\)
  outputs in the game \SICA.
  Hence, if \(k_{i^{*},j^{*}}' = k_{i^{*},j^{*}}\),
  then clearly \redM simulates \advA perfectly,
  and we will have \(s_{\redM} = s_{\redR}\).
  We have thus shown that
  \[
    \prob{s_{\redM} \ne s_{\redR}} \le \prob{\eventE_{abrt}} + \prob{\eventE_{key}},
  \]
  where we define the event \(\eventE_{key}\) by
  \[
    \eventE_{key} := \neg \eventE_{abrt} \land k_{i^{*},j^{*}}' \ne k_{i^{*},j^{*}}.
  \]

  To tackle the event \(\eventE_{key}\),
  we will need to make use of Lemma \ref{lemma:equiv}.
  We will also borrow the terminology of the aforementioned lemma
  and say that two secret keys \((\sk,\sk') \in \setSK^{2}\) for the KEM \KEM
  \emph{agree} on a ciphertext \(c\) if \(\Decaps(\sk,c) = \Decaps(\sk,c')\).
  Likewise, using the terminology of Definition \ref{def:bad},
  we will say that a pair of secret keys \((\sk,\sk')\) is \(\alpha\)-bad
  for a subset \(S \subset \{c_{i,1}c_{i,2},\ldots,c_{i,\rho}\}\)
  of the \(\rho\) encapsulations received on a given user \(i \in [\mu]\)
  in the \OWECPA game if \(\sk\) and \(\sk'\) agree
  on every ciphertext \(c_{i,j} \in \{c_{i,1},\ldots,c_{i,\rho}\}\)
  outside of the set \(S\),
  yet disagree on more than an \(\alpha\)-fraction of ciphertexts
  \(c_{i,j} \in \{c_{i,1},\ldots,c_{i,\rho}\}\)
  inside of the set \(S\).
  With this terminology, we can divide \(\eventE_{key}\) into the following events:
  \begin{itemize}[label={\textbullet},itemsep=0.1cm]
    \item \(\eventE_{bad} := \) The event \(\eventE_{abrt}\) does not occur
          (meaning that \redM obtains a secret key \(\sk_{i^{*}}'\) such that
          \(\Decaps(\sk_{i^{*}}',c_{i^{*},j}) = k_{i^{*},j}\) for each \(j \in [\rho] \setminus S_{i^{*}}\)),
          but the pair \((\sk_{i^{*}}, \sk_{i^{*}}')\) formed by \redM's secret key
          and the secret key \(\sk_{i^{*}}\) found by the real \advA in
          its brute-force search (Step \ref{advA:brute} of \advA)
          is \emph{\(\alpha\)-bad} for the subset of ciphertexts on user \(i^{*}\)
          indexed by the set \(S_{i^{*}}\).
    \item \(\eventE_{fail} := \) Neither \(\eventE_{abrt}\) nor \(\eventE_{bad}\) occur,
          but \(\eventE_{key}\) still occurs.
  \end{itemize}

  With this, we now get
  \[
    \prob{\eventE_{key}} \le \prob{\eventE_{bad}} + \prob{\eventE_{fail}}.
  \]
  We claim that
  \[
    \prob{\eventE_{fail}} \le \alpha.
  \]
  To this end, observe that if \(\eventE_{fail}\) occurs,
  then by definition \(\eventE_{abrt}\) does not, and so
  \redM will obtain a secret key \(\sk_{i^{*}}'\) such that
  \[
    \Decaps(\sk_{i^{*}}',c_{i^{*},j}) = k_{i^{*},j} \text{ for each } j \in [\rho] \setminus S_{i^{*}}.
  \]
  Hence such a secret key exists, and so \advA is guaranteed to find such a secret key \(\sk_{i^{*}}\)
  in its brute-force search as well (the two secret keys may not be the same).
  Thus we find that
  \[
    \Decaps(\sk_{i^{*}},c_{i^{*},j}) = k_{i^{*},j} = \Decaps(\sk_{i^{*}}',c_{i^{*},j}) \text{ for each } j \in [\rho] \setminus S_{i^{*}}.
  \]
  In other words, the secret keys \((\sk_{i^{*}},\sk_{i^{*}}')\)
  of \advA and \redM \emph{agree} on the ciphertexts on user \(i^{*}\) outside of the set indexed by \(S_{i^{*}}\).
  But if \(\eventE_{fail}\) occurs, then we also know that \(\eventE_{bad}\) does not
  (again, by the definition of \(\eventE_{fail}\)),
  and so the pair \((\sk_{i^{*}},\sk_{i^{*}}')\) of secret keys cannot be
  \(\alpha\)-bad for the subset \(S_{i^{*}}\).
  It follows by the definition of ``badness'' that \(\sk_{i^{*}}\) and \(\sk_{i^{*}}'\)
  can disagree on at most an \(\alpha\)-fraction of the ciphertexts inside of the set indexed by \(S_{i^{*}}\).
  That is, we can only have
  \(\Decaps(\sk_{i^{*}},c_{i^{*},j}) \ne \Decaps(\sk_{i^{*}}',c_{i^{*},j})\)
  for at most an \(\alpha\)-fraction of \(j \in S_{i^{*}}\).
  Now, since \(j^{*}\) is picked uniformly at random from \(S_{i^{*}}\),
  the probability that
  \(\Decaps(\sk_{i^{*}}',c_{i^{*},j}) \ne \Decaps(\sk_{i^{*}},c_{i^{*},j})\),
  or equivalently that \(k_{i^{*},j^{*}}' \ne k_{i^{*},j^{*}}\),
  is thus at most \(\alpha\),
  from which we get the desired bound.

  Finally, we can consider the event \(\eventE_{bad}\).
  % As before, since \(\eventE_{abrt}\) does not occur,
  % \redM finds a secret key
  % \(\sk_{i^{*}}'\) in \(\Simple'\) satisfying that
  % \(\KEM.\Decaps(\sk_{i^{*}}',c_{i^{*},j}) = k_{i^{*},j} \text{ for each } j \in [\rho] \setminus S_{i^{*}}\),
  % and hence
  % \advA will find such a secret key in \Simple as well, so it makes sense to speak of the pair \((\sk_{i^{*}}, \sk_{i^{*}}')\)
  % of secret keys held by \redM and \advA.
  From the definition of \(\eventE_{bad}\), it should be clear that
  \begin{equation}\label{ineq:M:bad}
    \prob*{\eventE_{bad}} \le \prob{\text{There exists a pair } (\sk,\sk') \text{ which is \(\alpha\)-bad for } S_{i^{*}}}.
  \end{equation}
  Now we can apply Lemma \ref{lemma:equiv} to bound the right hand side of \eqref{ineq:M:bad}.
  To do this, we will need to assign the sets \(\setSK, \setC, \keyspace\) referred to in the lemma,
  and also pick the function \(f : \setSK \times \setC \to \keyspace\),
  the set \(A \subset \setC\) of ciphertexts and the parameters \(d,\rho,t,\alpha\).
  We will let the sets \(\setSK, \setC, \keyspace\)
  be the same as they are here (i.e they will be the secret key space, ciphertext space and encapsulation key space of the KEM \KEM), and likewise for the parameters \(\rho, t, \alpha\).
  We then set \(d = q(\lambda)\),
  and let the function \(f\) be the decapsulation function \(\Decaps\) of \KEM.
  By our definition of a KEM (\TODO{define}), the decapsulation function
  \(\Decaps\) is a deterministic function from \(\setSK \times \setC\) to \(\keyspace\),
  and hence it makes sense to use it in our application of Lemma \ref{lemma:equiv}.
  Now we let \(A\) be the set of ciphertexts received on user \(i^{*}\), that is
  \[
    A = \{c_{i^{*},1},c_{i^{*},2},\ldots,c_{i^{*},\rho}\},
  \]
  and we set \(S\) to be the set of ciphertexts in \(A\) indexed by \(S_{i^{*}}\).
  Since \(S_{i^{*}}\) was chosen uniformly at random among size \(t\) subsets of \([\rho]\),
  the set \(S\) will be a uniformly random size \(t\) subset of \(A\).
  With this, Corollary \ref{corollary:equiv} of Lemma \ref{lemma:equiv} gives us
  \[
    \prob{\exists (\sk,\sk') \text{ which is \(\alpha\)-bad for } S_{i^{*}}}
    \le 4^{d} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \]

  Note that, for the application of Lemma \ref{lemma:equiv} to be formally correct here,
  we would actually need to verify that there are no duplicate ciphertexts
  \(c_{i^{*},j} = c_{i^{*},j'}\) among the ciphertexts received on user \(i^{*}\).
  Otherwise, the set \(A\) may not have size \(\rho\)
  (it could then be strictly smaller than \(\rho\)),
  and the set \(S\) could likewise be smaller than \(t\),
  so that the lemma would not apply.
  Now, for any secure KEM, we expect the probability of such a
  duplicate \(c_{i^{*},j} = c_{i^{*},j'}\) to be negligible in the real \OWECPA game.
  Nevertheless, we cannot assume that the same will hold
  when the reduction \redR acts as the challenger,
  as \redR could conceivably produce such duplicates regardless
  (recall that the reduction is free to do whatever it wishes, and does not need to
  faithfully emulate the real challenger in the \OWECPA game).
  However, if \advA ever receives such a duplicate \(c_{i^{*},j} = c_{i^{*},j'}\),
  then it can trivially win the \OWECPA game by revealing one of the ciphertexts and attacking the other.
  In this case, the adversary \advA's attack becomes efficient,
  and so we can simulate it efficiently towards \redR without issue.
  Hence we can ignore this technical detail.

  Combining the bounds for \(\prob{\eventE_{abrt}}\), \(\prob{\eventE_{bad}}\) and \(\prob{\eventE_{fail}}\), we now get
  \[
    \prob{s_{\redR} \ne s_{\redM}} \le 1 / \mu + \alpha
    + 4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t},
  \]
  which proves the lemma.
\end{proof}

\begin{lemma}[Lower bounding the success probability of \advA]\label{lemma:A}
  With the same setup as above, we have
  \begin{equation}\label{ineq:A:lemma}
    p_{\advA} \ge 1 - \alpha - \delta \mu \rho
    - 4^{d} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t},
  \end{equation}
\end{lemma}

\begin{proof}
  Recall that \(p_{\advA}\) denotes the success probability of the adversary \advA
  (as described in \TODO{ref.})
  in the \OWECPA game against \KEM.
  To be precise, this is the probability that \advA outputs a triple \((i^{*},j^{*},k^{*})\)
  such that
  \begin{itemize}[label={\textbullet},itemsep=0.1cm]
    \item \(k^{*}\) is the key encapsulated by \(c_{i^{*},j^{*}}\),
          where \(c_{i^{*},j^{*}}\) denotes the \(j^{*}\)-th encapsulation received on user \(i^{*}\)'s public key in the \OWECPA game against \KEM.
    \item The user \(i^{*}\) is not corrupted.
    \item The encapsulation \(c_{i^{*},j^{*}}\) has not been revealed.
  \end{itemize}

  Before we consider the output of \advA, let us bound
  the probability that \advA aborts early.
  This can happen in two ways:
  \begin{enumerate}
    \item\label{advA:abort1} One of the secret keys \(\sk_{i}\) received by \advA
          via a \(\Corrupt(i)\) query does not satisfy that \(\Decaps(\sk_{i}, c_{i,j}) = k_{i,j}\)
          for every \(j \in [\rho] \setminus S_{i}\).
    \item\label{advA:abort2} During \advA's brute-force search, \advA fails to find a candidate secret key \(\sk_{i^{*}}\)
          such that \(\Decaps(\sk_{i^{*}}, c_{i^{*},j}) = k_{i^{*},j}\) for every \(j \in [\rho] \setminus S_{i^{*}}\).
  \end{enumerate}
  Since we are in the real \OWECPA game against \KEM
  with an honest \OWECPA challenger,
  all of the secret keys \(\sk_{i}\) used by the challenger
  were validly generated, and the same holds for the encapsulations \(c_{i,j}\).
  Thus, by \((1 - \delta)\)-correctness,
  we will have \(\Decaps(\sk_{i},c_{i,j}) = k_{i,j}\) for every \(i \in [\mu]\) and \(j \in \rho\)
  except with probability \(\delta \mu \rho\),
  where \(k_{i,j}\) denotes the key that was generated along with \(c_{i,j}\) by the challenger in the \OWECPA game.
  In this case, clearly point \ref{advA:abort1} cannot occur.
  Likewise, point \ref{advA:abort2} will not occur,
  since the secret key \(\sk_{i^{*}}\) held by the challenger for user \(i^{*}\)
  satisfies that \(\Decaps(\sk_{i^{*}}, c_{i,j}) = k_{i,j} \text{ for every } j \in [\rho] \setminus S_{i^{*}}\).
  Because of this, a secret key \(\sk_{i^{*}}\) of the desired form exists,
  and \advA's brute-force search will not fail.
  Thus, the probability that \advA aborts before outputting anything is at most \(\delta \mu \rho\).

  Now, if neither point \ref{advA:abort1} nor point \ref{advA:abort2} occur,
  then \advA wins so long as the key
  \[
  k_{i^{*},j^{*}}' \assign \Decaps(\sk_{i^{*},j^{*}}, c_{i^{*},j^{*}})
  \]
  computed by \advA equals the true key encapsulated by \(c_{i^{*},j^{*}}\) in the game.
  Indeed, notice that the encapsulation \(c_{i^{*},j^{*}}\) is unrevealed
  and the user \(i^{*}\) is uncorrupted in the \OWECPA game,
  by the construction of the adversary \advA.
  Applying Lemma \ref{lemma:equiv}
  and reasoning similarly to Lemma \ref{lemma:M},
  we find that the pair of secret keys for user \(i^{*}\) held by \advA
  and the challenger in the \(\OWECPA\) game is
  \(\alpha\)-bad for the subset \(S_{i^{*}}\) with probability at most
  \(
    4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \)
  Thus the two secret keys will produce identical decapsulations of \(c_{i^{*},j^{*}}\), except with probability
  \(
    \alpha +
    4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \)
  Disregarding correctness errors among the \(\mu \rho\) encapsulations,
  (which we have already dealt with in our discussion of points 1 and 2),
  we find that the decapsulation of \(c_{i^{*},j^{*}}\)
  under the challenger's secret key for user \(i^{*}\)
  equals the true key encapsulated by \(c_{i^{*},j^{*}}\) in the \(\OWECPA\) game.
  Hence in this case, \advA wins except with probability
  \(
  \alpha
  + 4^{q(\lambda)} \cdot \left( \frac{t}{\rho - \alpha t + 1} \right)^{\alpha t}.
  \)
  Summing the failure probabilities, we now get \eqref{ineq:A:lemma}.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
